{"ast":null,"code":"// TODO: MOVE TO @onflow/util-batch\nimport { spawn, send, INIT } from \"@onflow/util-actor\";\nimport { uid } from \"@onflow/util-uid\";\nconst TICK = 500;\nconst BUFFER_SIZE = 10;\nconst SET_CALLBACK = \"SET_CALLBACK\";\nconst PROCESS = \"PROCESS\";\nconst MAYBE_PROCESS = \"MAYBE_PROCESS\";\nconst TIMEOUT = \"TIMEOUT\";\nconst ENQUEUE = \"ENQUEUE\";\nconst RESOLVE = \"RESOLVE\";\nconst HANDLERS = {\n  [INIT]: ctx => {\n    ctx.put(\"need\", new Set());\n    ctx.put(\"processing\", new Set());\n    ctx.put(\"hold\", {});\n    setInterval(() => ctx.sendSelf(TIMEOUT), TICK);\n  },\n  [SET_CALLBACK]: (ctx, letter, callback) => {\n    ctx.put(\"callback\", async (...args) => callback(...args));\n    ctx.sendSelf(MAYBE_PROCESS);\n  },\n  [ENQUEUE]: (ctx, letter, args) => {\n    const id = uid();\n    const hold = {\n      id,\n      args,\n      reply: letter.reply\n    };\n    ctx.update(\"need\", n => {\n      n.add(id);\n      return n;\n    });\n    ctx.update(\"hold\", h => ({ ...h,\n      [id]: hold\n    }));\n    ctx.sendSelf(MAYBE_PROCESS);\n  },\n  [TIMEOUT]: ctx => {\n    if (ctx.get(\"need\").size) ctx.sendSelf(PROCESS);\n  },\n  [MAYBE_PROCESS]: ctx => {\n    if (ctx.get(\"need\") >= BUFFER_SIZE) ctx.sendSelf(PROCESS);\n  },\n  [PROCESS]: ctx => {\n    const callback = ctx.get(\"callback\");\n    if (typeof callback !== \"function\") return;\n    const need = ctx.get(\"need\");\n    ctx.update(\"processing\", p => new Set([...p, ...need]));\n    ctx.put(\"need\", new Set());\n    const hold = ctx.get(\"hold\");\n    const payload = [...need].reduce((acc, key) => ({ ...acc,\n      [key]: hold[key].args\n    }), {});\n    callback(payload).then(result => {\n      ctx.sendSelf(RESOLVE, result);\n    });\n  },\n  [RESOLVE]: (ctx, _, results) => {\n    const have = Object.keys(results);\n\n    for (let h of have) {\n      const hold = ctx.get(\"hold\");\n      hold[h].reply(results[h]);\n      ctx.update(\"processing\", p => {\n        p.delete(h);\n        return p;\n      });\n      ctx.update(\"hold\", hold => {\n        delete hold[h];\n        return hold;\n      });\n    }\n  }\n};\nexport const batch = (name, callback) => {\n  spawn(HANDLERS, name);\n  send(name, SET_CALLBACK, callback);\n  return {\n    enqueue(...args) {\n      return send(name, ENQUEUE, args, {\n        expectReply: true,\n        timeout: 0\n      });\n    }\n\n  };\n};","map":{"version":3,"sources":["F:/kitty-items/web/src/flow/util/batch.js"],"names":["spawn","send","INIT","uid","TICK","BUFFER_SIZE","SET_CALLBACK","PROCESS","MAYBE_PROCESS","TIMEOUT","ENQUEUE","RESOLVE","HANDLERS","ctx","put","Set","setInterval","sendSelf","letter","callback","args","id","hold","reply","update","n","add","h","get","size","need","p","payload","reduce","acc","key","then","result","_","results","have","Object","keys","delete","batch","name","enqueue","expectReply","timeout"],"mappings":"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","sourcesContent":["// TODO: MOVE TO @onflow/util-batch\r\nimport {spawn, send, INIT} from \"@onflow/util-actor\"\r\nimport {uid} from \"@onflow/util-uid\"\r\n\r\nconst TICK = 500\r\nconst BUFFER_SIZE = 10\r\n\r\nconst SET_CALLBACK = \"SET_CALLBACK\"\r\nconst PROCESS = \"PROCESS\"\r\nconst MAYBE_PROCESS = \"MAYBE_PROCESS\"\r\nconst TIMEOUT = \"TIMEOUT\"\r\nconst ENQUEUE = \"ENQUEUE\"\r\nconst RESOLVE = \"RESOLVE\"\r\n\r\nconst HANDLERS = {\r\n  [INIT]: ctx => {\r\n    ctx.put(\"need\", new Set())\r\n    ctx.put(\"processing\", new Set())\r\n    ctx.put(\"hold\", {})\r\n    setInterval(() => ctx.sendSelf(TIMEOUT), TICK)\r\n  },\r\n\r\n  [SET_CALLBACK]: (ctx, letter, callback) => {\r\n    ctx.put(\"callback\", async (...args) => callback(...args))\r\n    ctx.sendSelf(MAYBE_PROCESS)\r\n  },\r\n\r\n  [ENQUEUE]: (ctx, letter, args) => {\r\n    const id = uid()\r\n    const hold = {id, args, reply: letter.reply}\r\n    ctx.update(\"need\", n => {\r\n      n.add(id)\r\n      return n\r\n    })\r\n    ctx.update(\"hold\", h => ({...h, [id]: hold}))\r\n    ctx.sendSelf(MAYBE_PROCESS)\r\n  },\r\n\r\n  [TIMEOUT]: ctx => {\r\n    if (ctx.get(\"need\").size) ctx.sendSelf(PROCESS)\r\n  },\r\n\r\n  [MAYBE_PROCESS]: ctx => {\r\n    if (ctx.get(\"need\") >= BUFFER_SIZE) ctx.sendSelf(PROCESS)\r\n  },\r\n\r\n  [PROCESS]: ctx => {\r\n    const callback = ctx.get(\"callback\")\r\n    if (typeof callback !== \"function\") return\r\n\r\n    const need = ctx.get(\"need\")\r\n    ctx.update(\"processing\", p => new Set([...p, ...need]))\r\n    ctx.put(\"need\", new Set())\r\n\r\n    const hold = ctx.get(\"hold\")\r\n    const payload = [...need].reduce(\r\n      (acc, key) => ({...acc, [key]: hold[key].args}),\r\n      {}\r\n    )\r\n\r\n    callback(payload).then(result => {\r\n      ctx.sendSelf(RESOLVE, result)\r\n    })\r\n  },\r\n  [RESOLVE]: (ctx, _, results) => {\r\n    const have = Object.keys(results)\r\n    for (let h of have) {\r\n      const hold = ctx.get(\"hold\")\r\n      hold[h].reply(results[h])\r\n      ctx.update(\"processing\", p => {\r\n        p.delete(h)\r\n        return p\r\n      })\r\n      ctx.update(\"hold\", hold => {\r\n        delete hold[h]\r\n        return hold\r\n      })\r\n    }\r\n  },\r\n}\r\n\r\nexport const batch = (name, callback) => {\r\n  spawn(HANDLERS, name)\r\n  send(name, SET_CALLBACK, callback)\r\n\r\n  return {\r\n    enqueue(...args) {\r\n      return send(name, ENQUEUE, args, {expectReply: true, timeout: 0})\r\n    },\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}