{"ast":null,"code":"// prettier-ignore\nimport { transaction, limit, proposer, payer, authorizations, authz, cdc } from \"@onflow/fcl\";\nimport { invariant } from \"@onflow/util-invariant\";\nimport { tx } from \"./util/tx\";\nconst CODE = cdc`\n  import FungibleToken from 0xFungibleToken\n  import NonFungibleToken from 0xNonFungibleToken\n  import Kibble from 0xKibble\n  import KittyItems from 0xKittyItems\n  import KittyItemsMarket from 0xKittyItemsMarket\n\n  pub fun hasKibble(_ address: Address): Bool {\n    let receiver = getAccount(address)\n      .getCapability<&Kibble.Vault{FungibleToken.Receiver}>(Kibble.ReceiverPublicPath)\n      .check()\n\n    let balance = getAccount(address)\n      .getCapability<&Kibble.Vault{FungibleToken.Balance}>(Kibble.BalancePublicPath)\n      .check()\n\n    return receiver && balance\n  }\n\n  pub fun hasItems(_ address: Address): Bool {\n    return getAccount(address)\n      .getCapability<&KittyItems.Collection{NonFungibleToken.CollectionPublic, KittyItems.KittyItemsCollectionPublic}>(KittyItems.CollectionPublicPath)\n      .check()\n  }\n\n  pub fun hasMarket(_ address: Address): Bool {\n    return getAccount(address)\n      .getCapability<&KittyItemsMarket.Collection{KittyItemsMarket.CollectionPublic}>(KittyItemsMarket.CollectionPublicPath)\n      .check()\n  }\n\n  transaction {\n    prepare(acct: AuthAccount) {\n      if !hasKibble(acct.address) {\n        if acct.borrow<&Kibble.Vault>(from: Kibble.VaultStoragePath) == nil {\n          acct.save(<-Kibble.createEmptyVault(), to: Kibble.VaultStoragePath)\n        }\n        acct.unlink(Kibble.ReceiverPublicPath)\n        acct.unlink(Kibble.BalancePublicPath)\n        acct.link<&Kibble.Vault{FungibleToken.Receiver}>(Kibble.ReceiverPublicPath, target: Kibble.VaultStoragePath)\n        acct.link<&Kibble.Vault{FungibleToken.Balance}>(Kibble.BalancePublicPath, target: Kibble.VaultStoragePath)\n      }\n\n      if !hasItems(acct.address) {\n        if acct.borrow<&KittyItems.Collection>(from: KittyItems.CollectionStoragePath) == nil {\n          acct.save(<-KittyItems.createEmptyCollection(), to: KittyItems.CollectionStoragePath)\n        }\n        acct.unlink(KittyItems.CollectionPublicPath)\n        acct.link<&KittyItems.Collection{NonFungibleToken.CollectionPublic, KittyItems.KittyItemsCollectionPublic}>(KittyItems.CollectionPublicPath, target: KittyItems.CollectionStoragePath)\n      }\n\n      if !hasMarket(acct.address) {\n        if acct.borrow<&KittyItemsMarket.Collection>(from: KittyItemsMarket.CollectionStoragePath) == nil {\n          acct.save(<-KittyItemsMarket.createEmptyCollection(), to: KittyItemsMarket.CollectionStoragePath)\n        }\n        acct.unlink(KittyItemsMarket.CollectionPublicPath)\n        acct.link<&KittyItemsMarket.Collection{KittyItemsMarket.CollectionPublic}>(KittyItemsMarket.CollectionPublicPath, target:KittyItemsMarket.CollectionStoragePath)\n      }\n    }\n  }\n`;\nexport async function initializeAccount(address, opts = {}) {\n  // prettier-ignore\n  invariant(address != null, \"Tried to initialize an account but no address was supplied\");\n  return tx([transaction(CODE), limit(70), proposer(authz), payer(authz), authorizations([authz])], opts);\n}","map":{"version":3,"sources":["F:/kitty-items/web/src/flow/initialize-account.tx.js"],"names":["transaction","limit","proposer","payer","authorizations","authz","cdc","invariant","tx","CODE","initializeAccount","address","opts"],"mappings":"AAAA;AACA,SAAQA,WAAR,EAAqBC,KAArB,EAA4BC,QAA5B,EAAsCC,KAAtC,EAA6CC,cAA7C,EAA6DC,KAA7D,EAAoEC,GAApE,QAA8E,aAA9E;AACA,SAAQC,SAAR,QAAwB,wBAAxB;AACA,SAAQC,EAAR,QAAiB,WAAjB;AAEA,MAAMC,IAAI,GAAGH,GAAI;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CA5DA;AA8DA,OAAO,eAAeI,iBAAf,CAAiCC,OAAjC,EAA0CC,IAAI,GAAG,EAAjD,EAAqD;AAC1D;AACAL,EAAAA,SAAS,CAACI,OAAO,IAAI,IAAZ,EAAkB,4DAAlB,CAAT;AAEA,SAAOH,EAAE,CACP,CACER,WAAW,CAACS,IAAD,CADb,EAEER,KAAK,CAAC,EAAD,CAFP,EAGEC,QAAQ,CAACG,KAAD,CAHV,EAIEF,KAAK,CAACE,KAAD,CAJP,EAKED,cAAc,CAAC,CAACC,KAAD,CAAD,CALhB,CADO,EAQPO,IARO,CAAT;AAUD","sourcesContent":["// prettier-ignore\r\nimport {transaction, limit, proposer, payer, authorizations, authz, cdc} from \"@onflow/fcl\"\r\nimport {invariant} from \"@onflow/util-invariant\"\r\nimport {tx} from \"./util/tx\"\r\n\r\nconst CODE = cdc`\r\n  import FungibleToken from 0xFungibleToken\r\n  import NonFungibleToken from 0xNonFungibleToken\r\n  import Kibble from 0xKibble\r\n  import KittyItems from 0xKittyItems\r\n  import KittyItemsMarket from 0xKittyItemsMarket\r\n\r\n  pub fun hasKibble(_ address: Address): Bool {\r\n    let receiver = getAccount(address)\r\n      .getCapability<&Kibble.Vault{FungibleToken.Receiver}>(Kibble.ReceiverPublicPath)\r\n      .check()\r\n\r\n    let balance = getAccount(address)\r\n      .getCapability<&Kibble.Vault{FungibleToken.Balance}>(Kibble.BalancePublicPath)\r\n      .check()\r\n\r\n    return receiver && balance\r\n  }\r\n\r\n  pub fun hasItems(_ address: Address): Bool {\r\n    return getAccount(address)\r\n      .getCapability<&KittyItems.Collection{NonFungibleToken.CollectionPublic, KittyItems.KittyItemsCollectionPublic}>(KittyItems.CollectionPublicPath)\r\n      .check()\r\n  }\r\n\r\n  pub fun hasMarket(_ address: Address): Bool {\r\n    return getAccount(address)\r\n      .getCapability<&KittyItemsMarket.Collection{KittyItemsMarket.CollectionPublic}>(KittyItemsMarket.CollectionPublicPath)\r\n      .check()\r\n  }\r\n\r\n  transaction {\r\n    prepare(acct: AuthAccount) {\r\n      if !hasKibble(acct.address) {\r\n        if acct.borrow<&Kibble.Vault>(from: Kibble.VaultStoragePath) == nil {\r\n          acct.save(<-Kibble.createEmptyVault(), to: Kibble.VaultStoragePath)\r\n        }\r\n        acct.unlink(Kibble.ReceiverPublicPath)\r\n        acct.unlink(Kibble.BalancePublicPath)\r\n        acct.link<&Kibble.Vault{FungibleToken.Receiver}>(Kibble.ReceiverPublicPath, target: Kibble.VaultStoragePath)\r\n        acct.link<&Kibble.Vault{FungibleToken.Balance}>(Kibble.BalancePublicPath, target: Kibble.VaultStoragePath)\r\n      }\r\n\r\n      if !hasItems(acct.address) {\r\n        if acct.borrow<&KittyItems.Collection>(from: KittyItems.CollectionStoragePath) == nil {\r\n          acct.save(<-KittyItems.createEmptyCollection(), to: KittyItems.CollectionStoragePath)\r\n        }\r\n        acct.unlink(KittyItems.CollectionPublicPath)\r\n        acct.link<&KittyItems.Collection{NonFungibleToken.CollectionPublic, KittyItems.KittyItemsCollectionPublic}>(KittyItems.CollectionPublicPath, target: KittyItems.CollectionStoragePath)\r\n      }\r\n\r\n      if !hasMarket(acct.address) {\r\n        if acct.borrow<&KittyItemsMarket.Collection>(from: KittyItemsMarket.CollectionStoragePath) == nil {\r\n          acct.save(<-KittyItemsMarket.createEmptyCollection(), to: KittyItemsMarket.CollectionStoragePath)\r\n        }\r\n        acct.unlink(KittyItemsMarket.CollectionPublicPath)\r\n        acct.link<&KittyItemsMarket.Collection{KittyItemsMarket.CollectionPublic}>(KittyItemsMarket.CollectionPublicPath, target:KittyItemsMarket.CollectionStoragePath)\r\n      }\r\n    }\r\n  }\r\n`\r\n\r\nexport async function initializeAccount(address, opts = {}) {\r\n  // prettier-ignore\r\n  invariant(address != null, \"Tried to initialize an account but no address was supplied\")\r\n\r\n  return tx(\r\n    [\r\n      transaction(CODE),\r\n      limit(70),\r\n      proposer(authz),\r\n      payer(authz),\r\n      authorizations([authz]),\r\n    ],\r\n    opts\r\n  )\r\n}\r\n"]},"metadata":{},"sourceType":"module"}